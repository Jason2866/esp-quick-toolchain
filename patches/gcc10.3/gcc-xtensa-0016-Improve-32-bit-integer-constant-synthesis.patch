From 68599b982eadea1566069563af7b000358807dc3 Mon Sep 17 00:00:00 2001
From: Takayuki 'January June' Suwa <jjsuwa_sys3175@yahoo.co.jp>
Date: Tue, 18 May 2021 01:30:25 +0900
Subject: [PATCH 09/19] xtensa: Improve 32-bit integer constant synthesis

This patch adds several new synthesis patterns - when the constant cannot fit
into a "MOVI Ax, simm12" instruction, but:

I.   can be represented as a power of two minus one (eg. 32767, 65535 or
     0x7fffffffUL)
       => "MOVI(.N) Ax, -1" + "SRLI Ax, Ax, 1 ... 31" (or "EXTUI")
II.  is between -34816 and 34559
       => "MOVI(.N) Ax, -2048 ... 2047" + "ADDMI Ax, Ax, -32768 ... 32512"
III. (existing case) can fit into a signed 12-bit if the trailing zero bits
     are stripped
       => "MOVI(.N) Ax, -2048 ... 2047" + "SLLI Ax, Ax, 1 ... 31"

The above sequences consist of 5 or 6 bytes and have latency of 2 clock cycles,
in contrast with "L32R Ax, <litpool>" (3 bytes and one clock latency, but may
suffer additional one clock pipeline stall and implementation-specific
InstRAM/ROM access penalty) plus 4 bytes of constant value.

In addition, 3-instructions synthesis patterns (8 or 9 bytes, 3 clock latency)
are also provided when optimizing for speed and L32R instruction has
considerable access penalty:

IV.  2-instructions synthesis (any of I ... III) followed by
     "SLLI Ax, Ax, 1 ... 31"

V.   2-instructions synthesis followed by either "ADDX[248] Ax, Ax, Ax"
     or "SUBX8 Ax, Ax, Ax" (multiplying by 3, 5, 7 or 9)

Furthermore, storing constant to memory (eg. '*p = 0x01800000UL;') become
to be subject to the insn expansion.

gcc/ChangeLog:

	* gcc/config/xtensa/xtensa.c (xtensa_emit_constsynth_pass2,
	xtensa_emit_constsynth_pass1, xtensa_emit_constsynth_SLLI,
	xtensa_emit_constsynth_ADDSUBX, xtensa_emit_constsynth):
	New worker functions that process the abovementioned logic.
	(xtensa_emit_move_sequence): Call the above functions before folding
	constants in the pool.

gcc/testsuite/ChangeLog:

	* gcc.target/xtensa/constsynth_2insns.c: New.
	* gcc.target/xtensa/constsynth_3insns.c: Ditto.
---
 gcc/config/xtensa/xtensa.c                    | 169 ++++++++++++++++--
 .../gcc.target/xtensa/constsynth_2insns.c     |  44 +++++
 .../gcc.target/xtensa/constsynth_3insns.c     |  24 +++
 3 files changed, 221 insertions(+), 16 deletions(-)
 create mode 100644 gcc/testsuite/gcc.target/xtensa/constsynth_2insns.c
 create mode 100644 gcc/testsuite/gcc.target/xtensa/constsynth_3insns.c

diff --git a/gcc/config/xtensa/xtensa.c b/gcc/config/xtensa/xtensa.c
index d160d57c5..94b3bdd1f 100644
--- a/gcc/config/xtensa/xtensa.c
+++ b/gcc/config/xtensa/xtensa.c
@@ -1027,6 +1027,152 @@ xtensa_split_operand_pair (rtx operands[4], machine_mode mode)
 }
 
 
+/* Try to emit insns to load srcval (that cannot fit into signed 12-bit) into
+   dst, with synthesizing a such constant value from a sequence of load-
+   immediate / arithmetic ones.  */
+
+static int
+xtensa_emit_constsynth_pass2 (rtx dst, enum rtx_code code,
+			      HOST_WIDE_INT imm0, HOST_WIDE_INT imm1,
+			      rtx (*gen_op)(rtx, HOST_WIDE_INT),
+			      HOST_WIDE_INT imm2)
+{
+  machine_mode dst_mode = GET_MODE (dst);
+
+  if (REG_P (dst) && dst_mode == SImode)
+    {
+      emit_move_insn (dst, GEN_INT (imm0));
+      emit_move_insn (dst, gen_rtx_fmt_ee (code, SImode,
+					   dst, GEN_INT (imm1)));
+      if (gen_op)
+	emit_move_insn (dst, gen_op (dst, imm2));
+
+      return 1;
+    }
+
+  if (can_create_pseudo_p ()
+      && (MEM_P (dst) || (REG_P (dst) && dst_mode != SImode)))
+    {
+      rtx x = force_reg (SImode, GEN_INT (imm0));
+
+      if (MEM_P (dst))
+	{
+	  emit_move_insn (x, gen_rtx_fmt_ee (code, SImode,
+					     x, GEN_INT (imm1)));
+	  if (gen_op)
+	    emit_move_insn (x, gen_op (x, imm2));
+	  emit_move_insn (dst, (dst_mode == SImode) ?
+			       x : convert_to_mode (dst_mode, x, true));
+	}
+      else if (gen_op)
+	{
+	  emit_move_insn (x, gen_rtx_fmt_ee (code, SImode,
+					     x, GEN_INT (imm1)));
+	  emit_move_insn (gen_rtx_SUBREG (SImode, dst, 0),
+			  gen_op (x, imm2));
+	}
+      else
+	emit_move_insn (gen_rtx_SUBREG (SImode, dst, 0),
+			gen_rtx_fmt_ee (code, SImode, x, GEN_INT (imm1)));
+
+      return 1;
+    }
+
+  return 0;
+}
+
+static int
+xtensa_emit_constsynth_pass1 (rtx dst, HOST_WIDE_INT srcval,
+			      rtx (*gen_op)(rtx, HOST_WIDE_INT),
+			      HOST_WIDE_INT imm2)
+{
+  int shift = exact_log2 (srcval + 1);
+
+  if (IN_RANGE (shift, 1, 31)
+      && xtensa_emit_constsynth_pass2 (dst, LSHIFTRT, -1, 32 - shift,
+				       gen_op, imm2))
+    return 1;
+
+  if (IN_RANGE (srcval, (-2048 - 32768), (2047 + 32512)))
+    {
+      HOST_WIDE_INT imm0, imm1;
+
+      if (srcval < -32768)
+	imm1 = -32768;
+      else if (srcval > 32512)
+	imm1 = 32512;
+      else
+	imm1 = srcval & ~255;
+      imm0 = srcval - imm1;
+      if (TARGET_DENSITY && imm1 < 32512 && IN_RANGE (imm0, 224, 255))
+	imm0 -= 256, imm1 += 256;
+      if (xtensa_emit_constsynth_pass2 (dst, PLUS, imm0, imm1,
+					gen_op, imm2))
+	return 1;
+    }
+
+    shift = ctz_hwi (srcval);
+    if (xtensa_simm12b (srcval >> shift)
+	&& xtensa_emit_constsynth_pass2 (dst, ASHIFT, srcval >> shift, shift,
+					 gen_op, imm2))
+      return 1;
+
+  return 0;
+}
+
+static rtx
+xtensa_emit_constsynth_SLLI (rtx r, HOST_WIDE_INT imm)
+{
+  return gen_rtx_ASHIFT (SImode, r, GEN_INT (imm));
+}
+
+static rtx
+xtensa_emit_constsynth_ADDSUBX (rtx r, HOST_WIDE_INT imm)
+{
+  return imm == 7
+	 ? gen_rtx_MINUS (SImode, gen_rtx_ASHIFT (SImode, r, GEN_INT (3)),
+			  r)
+	 : gen_rtx_PLUS (SImode, gen_rtx_ASHIFT (SImode, r,
+						 GEN_INT (floor_log2 (imm - 1))),
+			 r);
+}
+
+static int
+xtensa_emit_constsynth (rtx dst, HOST_WIDE_INT srcval)
+{
+  gcc_assert (!xtensa_simm12b (srcval));
+
+  /* 2-insns substitution.  */
+  if ((optimize_size || (optimize && xtensa_extra_l32r_costs >= 1))
+      && xtensa_emit_constsynth_pass1 (dst, srcval, NULL, 0))
+    return 1;
+
+  /* 3-insns substitution.  */
+  if (optimize > 1 && !optimize_size && xtensa_extra_l32r_costs >= 2)
+    {
+      int shift, divisor;
+
+      /* 2-insns substitution followed by SLLI.  */
+      shift = ctz_hwi (srcval);
+      if (IN_RANGE (shift, 1, 31)
+	  && xtensa_emit_constsynth_pass1 (dst, srcval >> shift,
+					   xtensa_emit_constsynth_SLLI,
+					   shift))
+	return 1;
+
+      /* 2-insns substitution followed by ADDX[248] or SUBX8.  */
+      for (divisor = 3; divisor <= 9; divisor += 2)
+	if (srcval % divisor == 0
+	    && xtensa_emit_constsynth_pass1 (dst, srcval / divisor,
+					     xtensa_emit_constsynth_ADDSUBX,
+					     divisor))
+	  return 1;
+    }
+
+  return 0;
+}
+
+
 /* Emit insns to move operands[1] into operands[0].
    Return 1 if we have written out everything that needs to be done to
    do the move.  Otherwise, return 0 and the caller will emit the move
@@ -1038,7 +1184,7 @@ xtensa_emit_move_sequence (rtx *operands, machine_mode mode)
   rtx src = operands[1];
 
   if (CONSTANT_P (src)
-      && (GET_CODE (src) != CONST_INT || ! xtensa_simm12b (INTVAL (src))))
+      && (! CONST_INT_P (src) || ! xtensa_simm12b (INTVAL (src))))
     {
       rtx dst = operands[0];
 
@@ -1064,21 +1210,12 @@ xtensa_emit_move_sequence (rtx *operands, machine_mode mode)
 
       if (! TARGET_AUTO_LITPOOLS && ! TARGET_CONST16)
 	{
-	  /* Try to emit MOVI + SLLI sequence, that is smaller
-	     than L32R + literal.  */
-	  if (optimize >= 1 && ! optimize_debug && mode == SImode
-	      && CONST_INT_P (src) && register_operand (dst, mode))
-	    {
-	      HOST_WIDE_INT srcval = INTVAL (src);
-	      int shift = ctz_hwi (srcval);
-
-	      if (xtensa_simm12b (srcval >> shift))
-		{
-		  emit_move_insn (dst, GEN_INT (srcval >> shift));
-		  emit_insn (gen_ashlsi3_internal (dst, dst, GEN_INT (shift)));
-		  return 1;
-		}
-	    }
+	  /* Try to emit a sequence of insns that is shorter or faster than
+	     "L32R" (plus a constant in litpool).  */
+	  if (! optimize_debug && (mode == SImode || mode == HImode)
+	      && GET_MODE (dst) == mode && CONST_INT_P (src)
+	      && xtensa_emit_constsynth (dst, INTVAL (src)))
+	    return 1;
 
 	  src = force_const_mem (SImode, src);
 	  operands[1] = src;
diff --git a/gcc/testsuite/gcc.target/xtensa/constsynth_2insns.c b/gcc/testsuite/gcc.target/xtensa/constsynth_2insns.c
new file mode 100644
index 000000000..ec2606ed1
--- /dev/null
+++ b/gcc/testsuite/gcc.target/xtensa/constsynth_2insns.c
@@ -0,0 +1,44 @@
+/* { dg-do compile } */
+/* { dg-options "-Os } */
+
+int test_0(void)
+{
+  return 4095;
+}
+
+int test_1(void)
+{
+  return 2147483647;
+}
+
+int test_2(void)
+{
+  return -34816;
+}
+
+int test_3(void)
+{
+  return -2049;
+}
+
+int test_4(void)
+{
+  return 2048;
+}
+
+int test_5(void)
+{
+  return 34559;
+}
+
+int test_6(void)
+{
+  return 43680;
+}
+
+void test_7(int *p)
+{
+  *p = -1432354816;
+}
+
+/* { dg-final { scan-assembler-not "l32r" } } */
diff --git a/gcc/testsuite/gcc.target/xtensa/constsynth_3insns.c b/gcc/testsuite/gcc.target/xtensa/constsynth_3insns.c
new file mode 100644
index 000000000..f3c4a1c7c
--- /dev/null
+++ b/gcc/testsuite/gcc.target/xtensa/constsynth_3insns.c
@@ -0,0 +1,24 @@
+/* { dg-do compile } */
+/* { dg-options "-O2 -mextra-l32r-costs=3" } */
+
+int test_0(void)
+{
+  return 134217216;
+}
+
+int test_1(void)
+{
+  return -27604992;
+}
+
+int test_2(void)
+{
+  return -162279;
+}
+
+void test_3(int *p)
+{
+  *p = 192437;
+}
+
+/* { dg-final { scan-assembler-not "l32r" } } */
-- 
2.20.1

